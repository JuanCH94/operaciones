# -*- coding: utf-8 -*-
"""funciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17oda-oVio-DwZegnAKhLnEjKXZI3sDml
"""

# funciones.py

import os
from PIL import Image 
from pathlib import Path
import numpy as np
import numpy as np
from sklearn.utils import shuffle
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import matplotlib.pyplot as plt
import tensorflow as tf
                     

# --- Función para redimensionar y copiar ---
# Esta función toma un DataFrame con rutas de imágenes y etiquetas,
# el nombre del subconjunto (ej. 'train', 'val', 'test'),
# la ruta base donde se guardarán los resultados,
# y el tamaño al que se redimensionarán las imágenes.
def resize_and_copy(df_split, split_name, output_base, image_size):
    # Itera sobre cada fila del DataFrame (df_split)
    for _, row in df_split.iterrows():
        label = row['label']          # Obtiene la etiqueta de la imagen (ej. 'glioma')
        src = row['filepath']         # Obtiene la ruta de origen de la imagen

        # Construye la ruta de destino:
        # output_base/split_name/label/nombre_imagen.jpg
        # Ejemplo: /content/drive/MyDrive/operaciones/salidas/data_modelo/train/glioma/imagen_001.jpg
        dst_dir = os.path.join(output_base, split_name, label)
        # Crea el directorio de destino si no existe. exist_ok=True evita errores si ya existe.
        os.makedirs(dst_dir, exist_ok=True)
        # Construye la ruta completa del archivo de destino, manteniendo el nombre original de la imagen.
        dst_path = os.path.join(dst_dir, os.path.basename(src))

        try:
            # Abre la imagen desde la ruta de origen
            img = Image.open(src)
            # Asegura que la imagen tenga 3 canales (RGB) para consistencia.
            # Algunas imágenes podrían ser en escala de grises o tener canal alfa.
            img = img.convert('RGB')
            # Redimensiona la imagen al tamaño especificado (ancho, alto).
            img = img.resize(image_size)
            # Guarda la imagen redimensionada en la ruta de destino.
            img.save(dst_path)
        except Exception as e:
            # Captura cualquier error que ocurra durante el procesamiento de una imagen
            # e imprime un mensaje de error sin detener el proceso completo.
            print(f"Error al procesar {src}: {e}")


def cargar_imagenes_en_array(path):
    x_data = []
    y_data = []
    file_list = []

    path = Path(path)
    clases = sorted([carpeta.name for carpeta in path.iterdir() if carpeta.is_dir()])
    clase_a_indice = {clase: idx for idx, clase in enumerate(clases)}

    for clase in clases:
        carpeta = path / clase
        for imagen_path in carpeta.glob('*.*'):
            try:
                img = Image.open(imagen_path).convert('RGB')
                arr = np.array(img)
                x_data.append(arr)
                y_data.append(clase_a_indice[clase])
                file_list.append(imagen_path.name)
            except Exception as e:
                print(f"Error con la imagen: {imagen_path} | {e}")

    return np.array(x_data), np.array(y_data), file_list


    # Función para balancear un conjunto de datos (train o test)
def balance_datasets(x, y, datagen):
    classes, counts = np.unique(y, return_counts=True)
    max_count = max(counts)
    x_aug = []
    y_aug = []

    for c in classes:
        x_class = x[y == c]
        y_class = y[y == c]
        n_samples_needed = max_count - len(x_class)

        # Agregar los datos originales
        x_aug.extend(x_class)
        y_aug.extend(y_class)

        # Generar muestras augmentadas si es necesario
        if n_samples_needed > 0:
            # Reshape para que datagen.flow funcione correctamente con un solo lote
            x_class_reshaped = np.expand_dims(x_class, axis=1)
            y_class_reshaped = np.expand_dims(y_class, axis=1)

            gen = datagen.flow(x_class, y_class, batch_size=1)
            for _ in range(n_samples_needed):
                x_gen, y_gen = next(gen)
                x_aug.append(x_gen[0])
                y_aug.append(y_gen[0])

    # Convertir a arrays numpy
    x_balanced = np.array(x_aug)
    y_balanced = np.array(y_aug)

    # Barajar (opcional pero recomendable)
    x_balanced, y_balanced = shuffle(x_balanced, y_balanced, random_state=42)

    return x_balanced, y_balanced

# Función para generar Grad-CAM 
def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )
    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(predictions[0])
        class_channel = predictions[:, pred_index]

    grads = tape.gradient(class_channel, conv_outputs)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))
    conv_outputs = conv_outputs[0]
    heatmap = conv_outputs @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)
    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

# Función para superponer heatmap a la imagen
def superimpose_heatmap(img, heatmap, alpha=0.4):
    import cv2
    heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))
    heatmap = np.uint8(255 * heatmap)
    heatmap_color = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    superimposed_img = heatmap_color * alpha + img
    superimposed_img = np.clip(superimposed_img, 0, 255).astype(np.uint8)
    return superimposed_img

# Ejemplo para mostrar imágenes y predicciones con Grad-CAM
def show_images_with_gradcam(model, dataset, start_idx, end_idx, last_conv_layer_name):
    for i in range(start_idx, end_idx):
        img = dataset[i]
        img_array = np.expand_dims(img, axis=0)  # Expandir dims para batch
        preds = model.predict(img_array)
        pred_class = np.argmax(preds[0])
        pred_label = class_names[pred_class]

        heatmap = make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_class)
        img_uint8 = (img * 255).astype(np.uint8)  # Si tu imagen está en [0,1]
        superimposed_img = superimpose_heatmap(img_uint8, heatmap)

        plt.figure(figsize=(10,4))

        plt.subplot(1, 3, 1)
        plt.title('Imagen Original')
        plt.imshow(img)
        plt.axis('off')

        plt.subplot(1, 3, 2)
        plt.title('Heatmap Grad-CAM')
        plt.imshow(heatmap, cmap='jet')
        plt.axis('off')

        plt.subplot(1, 3, 3)
        plt.title(f'Imagen + Heatmap\nPredicción: {pred_label}')
        plt.imshow(superimposed_img)
        plt.axis('off')

        plt.show()


    